#!/usr/bin/env python

"""
Enumerate_Backplanes - create an easy-to-use table to reference backplanes
"""

import re
import os
import sys
import math
import time

from subprocess import Popen, PIPE, STDOUT
from prettytable import PrettyTable

# Our current depots have 24 slots on the Front backplane and 12 on the Rear.  
# In a more complex setup, we might need a more cumbersome way to alias backplanes
Alias_by_NumSlots = {}
Alias_by_NumSlots["24"] = "Front"
Alias_by_NumSlots["12"] = "Back"

# Cache info
CacheDataArray = {}
CacheTimeArray = {}

# Array to hold the output for pretty printing
Output = []

def SysExec(cmd):

        """
        Run the given command and return the output.  Cache the output for faster response time if it is fresh enough.
        """

        # Cache the output of the command for 20 seconds
        Cache_Expires = 20

        # Computed once, used twice
        Cache_Keys = list(CacheDataArray.keys())
        if cmd in Cache_Keys:
                Cache_Age  = time.time() - CacheTimeArray[cmd]
        else:
                Cache_Age  = 0

        # If we have valid data cached, return it
        if cmd in Cache_Keys and Cache_Age < Cache_Expires:
                return CacheDataArray[cmd]

        # If the cmd is "cat", use fopen/fread/fclose to open it and
        # cache it as we go
        if cmd.split()[0] == "cat":
                f = open(cmd.split()[1], "r")
                CacheDataArray[cmd] = f.read()
                CacheTimeArray[cmd] = time.time()
                f.close()
                return CacheDataArray[cmd]

        # If we don't have cached data, or it's too old, regenerate it
        if not cmd in Cache_Keys or Cache_Age > Cache_Expires:
                CacheDataArray[cmd] = Popen(cmd.split(), stdout=PIPE, stderr=STDOUT).communicate()[0]
                CacheTimeArray[cmd] = time.time()
                return CacheDataArray[cmd]

        return "ERROR"

Enclosure_Raw = SysExec("lsscsi -g")
for line in Enclosure_Raw.splitlines():

	if not re.search("enclosu", line):
		continue

	SG_Dev = line.split()[-1]

	SG_Bus = line.split()[0]
	SG_Bus = re.sub("\[", "", SG_Bus)
	SG_Bus = re.sub("\]", "", SG_Bus)

	SAS_Addr = "UNKNOWN_SAS"
	SAS_Addr_Raw = SysExec("sg_ses --page=aes " + SG_Dev)
	for text in SAS_Addr_Raw.splitlines():
		if re.search("Primary enclosure logical identifier", text):
			SAS_Addr = text.split(":")[1]
			SAS_Addr = re.sub(" ", "", SAS_Addr)

	Num_Slots = "UNKNOWN_SLOTS"
	Num_Slots_Raw  = SysExec("sg_ses --page=cf " + SG_Dev)
	match = re.search(r'Array device slot(.*)ArrayDevicesInSubEnclsr0', Num_Slots_Raw, re.DOTALL)
	match = match.group(0)
	for l in match.splitlines():
		if re.search("number of possible elements", l):
			Num_Slots = l.split(":")[-1]
			Num_Slots = re.sub(" ", "", Num_Slots)


	Alias = "UNKNOWN_ALIAS"
	if Num_Slots in Alias_by_NumSlots:
		Alias = Alias_by_NumSlots[Num_Slots]	

	# Instead of printing here, just create an array and print later, so we can pretty-print it
	Output.append([SG_Dev, Num_Slots, SG_Bus, SAS_Addr, Alias])
#	print(SG_Dev + "," + Num_Slots + "," + SAS_Addr + "," + Alias)


x = PrettyTable(["SG_Dev", "Num_Slots", "SG_Bus", "SAS_Addr", "Alias"])
x.padding_width = 1
for row in Output:
	x.add_row(row)
print(x)
